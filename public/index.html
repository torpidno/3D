<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ladda upp 3MF/STL</title>
  <link rel="icon" type="image/png" href="/Pauli.png" />
  <style>
    :root{--bg:#0f172a;--card:#111827;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--ok:#22c55e;--err:#ef4444}
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      background:#020617;
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      min-height:100vh;
      position:relative;
    }
    .hero {
      height: 100vh;
      min-height: unset;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.25);
      padding: 0 20px;
      overflow: hidden;
      z-index: 1;
    }
    .hero-content {
      margin-top: 0;
      position: relative;
      z-index: 2;
    }
    .hero::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(140deg, rgba(10, 22, 43, 0.85) 20%, rgba(8, 47, 73, 0.55) 60%, rgba(12, 74, 110, 0.3) 100%);
      mix-blend-mode: screen;
      pointer-events: none;
      z-index: 1;
    }
    .hero h1 {
      font-size: 2.7rem;
      margin-bottom: 12px;
      color: #fff;
      letter-spacing: 1px;
      text-shadow: 0 2px 16px #0f172a99;
    }
    .hero p {
      color: #e0e7ef;
      font-size: 1.2rem;
      margin-bottom: 32px;
      text-shadow: 0 1px 8px #0f172a66;
    }
    .admin-link {
      position: absolute;
      top: 24px;
      right: 32px;
      color: #93c5fd;
      background: rgba(17,24,39,0.7);
      padding: 8px 16px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 500;
      box-shadow: 0 2px 8px #0f172a33;
      transition: background 0.2s;
    }
    .admin-link:hover {
      background: #60a5fa;
      color: #0f172a;
    }
    #formSection {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      height: auto;
      padding: 48px 0 64px;
      position: relative;
      z-index: 1;
    }
    .card{width:100%;max-width:720px;background:rgba(17,24,39,0.6);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:28px;box-shadow:0 10px 30px rgba(0,0,0,0.45)}
    h2{margin:0 0 6px 0;font-size:28px}
    p{margin:0 0 18px 0;color:var(--muted)}
    label{display:block;margin:14px 0 6px}
    input,select,textarea{width:100%;padding:12px 14px;border:1px solid rgba(255,255,255,0.12);border-radius:10px;background:rgba(255,255,255,0.06);color:var(--text);outline:none}
    select{appearance:none;-webkit-appearance:none;-moz-appearance:none;background-color:rgba(255,255,255,0.08);color:var(--text);font-size:14px}
    option{background:#111827;color:var(--text);font-size:14px}
    select:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(96,165,250,0.25)}
    textarea{min-height:110px}
    input[type=file]{padding:10px}
    .file-drop {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      min-height: 64px;
      background: rgba(96,165,250,0.08);
      border: 2px dashed var(--accent);
      border-radius: 12px;
      color: var(--text);
      font-size: 1rem;
      cursor: pointer;
      margin-bottom: 12px;
      transition: background 0.2s, border-color 0.2s;
      text-align: center;
      position: relative;
      padding: 18px 0;
    }
    .file-drop:hover, .file-drop.dragover {
      background: rgba(96,165,250,0.18);
      border-color: #60a5fa;
    }
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .row > div{min-width:0}
    .hint{font-size:12px;color:var(--muted)}
    .btn{margin-top:18px;display:inline-flex;align-items:center;gap:8px;background:var(--accent);color:#0b1020;border:none;padding:12px 16px;border-radius:10px;font-weight:600;cursor:pointer}
    .msg{margin-top:12px;font-size:14px}
    .ok{color:var(--ok)}
    .err{color:var(--err)}
    .scroll-down {
      display: inline-block;
      margin-top: 10px;
      font-size: 2.5rem;
      color: #fff;
      background: rgba(96,165,250,0.18);
      border-radius: 50%;
      width: 54px;
      height: 54px;
      line-height: 54px;
      text-align: center;
      box-shadow: 0 2px 12px #0f172a44;
      transition: background 0.2s, transform 0.2s;
      text-decoration: none;
      pointer-events: none;
    }
    .scroll-down:hover {
      background: #60a5fa;
      color: #0f172a;
      transform: translateY(4px) scale(1.08);
    }
    /* Scope background canvas styling only to the hero background canvas */
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      filter: saturate(1.2);
    }
    /* Ensure the preview canvas fits inside its container and stays interactive */
    #viewer { position: relative; }
    #viewer canvas { width: 100% !important; height: 100% !important; display: block; position: absolute; inset: 0; }
  </style>
</head>
<body>
  <header class="hero">
    <div class="hero-content">
      <h1>Välkommen till 3D-Utskriftsportalen</h1>
      <p>Skicka in din 3D-modell och få den utskriven av Noah eller Alex.<br>Snabbt, enkelt och smidigt.</p>
      <span class="scroll-down" aria-hidden="true">&#8595;</span>
    </div>
    <a class="admin-link" href="/admin">Admin</a>
  </header>

  <section id="formSection">
    <div class="card">
      <h2 style="margin-top:0">Ladda upp din 3D-modell</h2>
      <p>Fyll i formuläret och ladda upp en <strong>.3mf</strong> eller <strong>.stl</strong>-fil.</p>
      <form id="uploadForm" enctype="multipart/form-data">
        <label for="namn">Namn *</label>
        <input id="namn" name="namn" type="text" required />

        <label for="mejl">Mejl *</label>
        <input id="mejl" name="mejl" type="email" required />

        <label for="beskrivning">Kort beskrivning *</label>
        <textarea id="beskrivning" name="beskrivning" required></textarea>

        <div class="row">
          <div>
            <label for="preferens">Har du preferens på vem *</label>
            <select id="preferens" name="preferens" required>
              <option value="" disabled selected>Laddar användare...</option>
            </select>
          </div>
          <div>
            <label for="brattom">Hur bråttom *</label>
            <select id="brattom" name="brattom" required>
              <option value="" disabled selected>Välj...</option>
              <option value="Inte bråttom">Inte bråttom</option>
              <option value="Snart">Snart</option>
              <option value="Mycket bråttom">Mycket bråttom</option>
            </select>
          </div>
        </div>

        <label for="modelFile">Lägg in din 3mf eller stl fil här *</label>
        <label for="modelFile" class="file-drop">
          <span id="fileLabelText">Välj eller släpp fil här (.3mf eller .stl)</span>
          <input id="modelFile" name="fil" type="file" accept=".stl,.3mf" required style="display:none" />
        </label>

        <!-- 3D Preview (shown when a file is selected) -->
        <div id="previewSection" style="display:none; margin-top:16px">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
            <strong>Förhandsvisning</strong>
            <small style="color:var(--muted)">Dra för att rotera • Scrolla för att zooma</small>
          </div>
          <div id="viewer" style="width:100%;height:360px;border:1px solid rgba(255,255,255,0.12);border-radius:10px;background:rgba(255,255,255,0.04);"></div>
          <div id="previewMsg" class="hint" style="margin-top:8px"></div>
        </div>

        <button class="btn" type="submit">Skicka in</button>
        <div class="msg" id="msg"></div>
      </form>
    </div>
  </section>

  <canvas id="canvas"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Three.js extras for preview -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/3MFLoader.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 10);

    const ambientLight = new THREE.AmbientLight(0xadc8ff, 0.6);
    const frontLight = new THREE.PointLight(0xffffff, 1.35);
    frontLight.position.set(5, 4, 6);
    const rimLight = new THREE.PointLight(0x60a5fa, 0.9);
    rimLight.position.set(-6, -3, -2);
    scene.add(ambientLight, frontLight, rimLight);

    const heroGroup = new THREE.Group();
    scene.add(heroGroup);

  const palette = [0x60a5fa, 0x7c3aed, 0x38bdf8, 0x8b7ab8];
    const makeMaterial = (color) => new THREE.MeshStandardMaterial({
      color,
      metalness: 0.6,
      roughness: 0.25,
      emissive: color,
      emissiveIntensity: 0.18
    });

    const prism = new THREE.Mesh(new THREE.IcosahedronGeometry(1.6, 0), makeMaterial(palette[0]));
    prism.position.set(-2.8, 0.6, 0);
    heroGroup.add(prism);

    const knot = new THREE.Mesh(new THREE.TorusKnotGeometry(1.05, 0.32, 180, 24), makeMaterial(palette[1]));
    knot.position.set(2.6, -0.4, 0.2);
    heroGroup.add(knot);

    const bubble = new THREE.Mesh(new THREE.SphereGeometry(1.2, 42, 42), makeMaterial(palette[2]));
    bubble.position.set(0.2, 1.8, -1.2);
    heroGroup.add(bubble);

  const gem = new THREE.Mesh(new THREE.OctahedronGeometry(1.35, 0), makeMaterial(palette[3]));
  gem.position.set(-0.6, -2.2, 0.4);
  heroGroup.add(gem);

  const heroObjects = [prism, knot, bubble, gem];
  const heroRadii = [1.4, 1.2, 1.05, 1.25];
    heroObjects.forEach((obj, idx) => {
      obj.userData.velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04,
        0
      );
      obj.userData.maxSpeed = 0.05 - idx * 0.006;
    });

  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 160;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      starPositions[i * 3] = (Math.random() - 0.5) * 32;
      starPositions[i * 3 + 1] = (Math.random() - 0.5) * 32;
      starPositions[i * 3 + 2] = -Math.random() * 20;
    }
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({
      color: 0x60a5fa,
      size: 0.05,
      transparent: true,
      opacity: 0.75,
      sizeAttenuation: true
    });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

  const mouseTarget = new THREE.Vector2(0, 0);
  const parallax = new THREE.Vector2(0, 0);
  const floatBounds = new THREE.Vector2();
  const updateFloatBounds = () => {
    const depth = camera.position.z;
    const halfHeight = Math.tan(THREE.MathUtils.degToRad(camera.fov / 2)) * depth;
    const halfWidth = halfHeight * camera.aspect;
    floatBounds.set(halfWidth * 0.82, halfHeight * 0.78);
  };
  updateFloatBounds();

    window.addEventListener('pointermove', (event) => {
      const x = (event.clientX / window.innerWidth) * 2 - 1;
      const y = -(event.clientY / window.innerHeight) * 2 + 1;
      mouseTarget.set(x, y);
      pointer.set(x, y);
    });

    window.addEventListener('pointerleave', () => {
      mouseTarget.set(0, 0);
      pointer.set(0, 0);
    });

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();

  raycaster.setFromCamera(pointer, camera);
  const intersections = raycaster.intersectObjects(heroObjects, false);
  const hoverHit = intersections.length ? intersections[0] : null;

    prism.rotation.x -= 0.004 + parallax.y * 0.0012;
    prism.rotation.y += 0.006;
    knot.rotation.y += 0.01 + parallax.x * 0.0025;
    knot.rotation.x -= 0.003;
    bubble.rotation.y += 0.006;
  gem.rotation.y -= 0.008 + parallax.x * 0.0015;
  gem.rotation.x += 0.004;

      heroObjects.forEach((obj, idx) => {
        const vel = obj.userData.velocity;
        const maxSpeed = obj.userData.maxSpeed;

        vel.x += (Math.random() - 0.5) * 0.0012;
        vel.y += (Math.random() - 0.5) * 0.0012;

        vel.x += parallax.x * 0.0004;
        vel.y += parallax.y * 0.0004;

        if (hoverHit && hoverHit.object === obj) {
          const repelDir = obj.position.clone().sub(hoverHit.point);
          if (repelDir.lengthSq() < 0.0001) {
            repelDir.set(mouseTarget.x || 0.0001, mouseTarget.y || 0.0001, 0);
          }
          repelDir.normalize();
          const repelStrength = 0.015 + idx * 0.004;
          vel.x += repelDir.x * repelStrength;
          vel.y += repelDir.y * repelStrength;
        }

        vel.multiplyScalar(0.995);
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          vel.x *= scale;
          vel.y *= scale;
        }

        obj.position.x += vel.x;
        obj.position.y += vel.y;
        obj.position.z = Math.sin(elapsed * 0.35 + idx) * 1.6;

        if (obj.position.x > floatBounds.x) {
          obj.position.x = floatBounds.x;
          vel.x *= -0.85;
        } else if (obj.position.x < -floatBounds.x) {
          obj.position.x = -floatBounds.x;
          vel.x *= -0.85;
        }

        if (obj.position.y > floatBounds.y) {
          obj.position.y = floatBounds.y;
          vel.y *= -0.85;
        } else if (obj.position.y < -floatBounds.y) {
          obj.position.y = -floatBounds.y;
          vel.y *= -0.85;
        }
      });

      for (let i = 0; i < heroObjects.length; i++) {
        for (let j = i + 1; j < heroObjects.length; j++) {
          const objA = heroObjects[i];
          const objB = heroObjects[j];
          const dx = objA.position.x - objB.position.x;
          const dy = objA.position.y - objB.position.y;
          const distSq = dx * dx + dy * dy;
          const minDist = heroRadii[i] + heroRadii[j];
          if (distSq < minDist * minDist) {
            const dist = Math.sqrt(distSq) || 0.0001;
            const nx = dx / dist;
            const ny = dy / dist;
            const overlap = (minDist - dist) * 0.5;

            objA.position.x += nx * overlap;
            objA.position.y += ny * overlap;
            objB.position.x -= nx * overlap;
            objB.position.y -= ny * overlap;

            const velA = objA.userData.velocity;
            const velB = objB.userData.velocity;
            const va = velA.x * nx + velA.y * ny;
            const vb = velB.x * nx + velB.y * ny;
            const impulse = vb - va;

            velA.x += impulse * nx;
            velA.y += impulse * ny;
            velB.x -= impulse * nx;
            velB.y -= impulse * ny;
          }
        }
      }

      stars.rotation.z += 0.0005 + parallax.x * 0.0008;

      parallax.x += (mouseTarget.x * 0.9 - parallax.x) * 0.04;
      parallax.y += (mouseTarget.y * 0.6 - parallax.y) * 0.04;

      camera.position.x = parallax.x * 2;
      camera.position.y = parallax.y * 1.4;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      updateFloatBounds();
    });

    const form = document.getElementById('uploadForm');
    const msg = document.getElementById('msg');
    
    // Load users dynamically for preferens dropdown
    (async function loadUsers() {
      const preferensSelect = document.getElementById('preferens');
      try {
        const res = await fetch('/api/users');
        if (res.ok) {
          const users = await res.json();
          // Clear loading option
          preferensSelect.innerHTML = '<option value="" disabled selected>Välj...</option>';
          
          // Add each user (capitalized username)
          users.forEach(u => {
            const displayName = u.username.charAt(0).toUpperCase() + u.username.slice(1);
            const option = document.createElement('option');
            option.value = displayName;
            option.textContent = displayName;
            preferensSelect.appendChild(option);
          });
          
          // Add "Vem som" option at the end
          const vemsomOption = document.createElement('option');
          vemsomOption.value = 'Vem som';
          vemsomOption.textContent = 'Vem som';
          preferensSelect.appendChild(vemsomOption);
        } else {
          // Fallback if API fails
          preferensSelect.innerHTML = '<option value="" disabled selected>Välj...</option><option value="Vem som">Vem som</option>';
        }
      } catch (err) {
        console.error('Failed to load users:', err);
        // Fallback if API fails
        preferensSelect.innerHTML = '<option value="" disabled selected>Välj...</option><option value="Vem som">Vem som</option>';
      }
    })();
    
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      msg.textContent = '';
      const fd = new FormData(form);
      try {
        const res = await fetch('/api/submit', { method: 'POST', body: fd, headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
          const err = await res.json().catch(()=>({ error: 'Något gick fel' }));
          msg.textContent = err.error || 'Något gick fel';
          msg.className = 'msg err';
          return;
        }
        msg.textContent = 'Tack! Din modell har skickats in.';
        msg.className = 'msg ok';
        form.reset();
      } catch (err) {
        msg.textContent = 'Kunde inte skicka. Kontrollera din uppkoppling.';
        msg.className = 'msg err';
      }
    });

    // Custom file input logic
    const fileInput = document.getElementById('modelFile');
    const fileLabel = document.querySelector('.file-drop');
    const fileLabelText = document.getElementById('fileLabelText');
    if (fileInput && fileLabel && fileLabelText) {
      fileInput.addEventListener('change', function() {
        if (fileInput.files && fileInput.files.length > 0) {
          fileLabelText.textContent = fileInput.files[0].name;
          // Try to preview the model
          setupPreviewForFile(fileInput.files[0]);
        } else {
          fileLabelText.textContent = 'Välj eller släpp fil här (.3mf eller .stl)';
          teardownPreview();
        }
      });
      fileLabel.addEventListener('dragover', function(e) {
        e.preventDefault();
        fileLabel.classList.add('dragover');
      });
      fileLabel.addEventListener('dragleave', function(e) {
        fileLabel.classList.remove('dragover');
      });
      fileLabel.addEventListener('drop', function(e) {
        e.preventDefault();
        fileLabel.classList.remove('dragover');
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          fileInput.dispatchEvent(new Event('change'));
        }
      });
      // Clicking the label already triggers the hidden input via the `for` attribute.
      // Avoid programmatic `.click()` here to prevent some browsers from requiring a double selection.
    }

    // ===== 3D Preview Logic =====
    let previewRenderer, previewScene, previewCamera, previewControls, previewRoot, previewAnimId;
    const previewSection = document.getElementById('previewSection');
    const viewer = document.getElementById('viewer');
    const previewMsg = document.getElementById('previewMsg');

    function ensurePreviewInit() {
      if (previewRenderer) return;
      previewScene = new THREE.Scene();
      previewScene.background = null;
      const w = viewer.clientWidth;
      const h = viewer.clientHeight;
      previewCamera = new THREE.PerspectiveCamera(50, w / h, 0.01, 1000);
      previewCamera.position.set(0, 0.2, 0.6);

      previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      previewRenderer.setSize(w, h);
      viewer.innerHTML = '';
      viewer.appendChild(previewRenderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
      hemi.position.set(0, 1, 0);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(1, 1, 1);
      previewScene.add(hemi, dir);

      previewControls = new THREE.OrbitControls(previewCamera, previewRenderer.domElement);
      previewControls.enableDamping = true;
      previewControls.dampingFactor = 0.07;
      previewControls.target.set(0, 0, 0);

      previewRoot = new THREE.Group();
      previewScene.add(previewRoot);

      const grid = new THREE.GridHelper(1, 10, 0x406080, 0x203040);
      grid.material.opacity = 0.2;
      grid.material.transparent = true;
      previewScene.add(grid);

      animatePreview();
      window.addEventListener('resize', onPreviewResize);
    }

    function onPreviewResize() {
      if (!previewRenderer) return;
      const w = viewer.clientWidth;
      const h = viewer.clientHeight;
      previewRenderer.setSize(w, h);
      previewCamera.aspect = w / h;
      previewCamera.updateProjectionMatrix();
    }

    function animatePreview() {
      previewAnimId = requestAnimationFrame(animatePreview);
      if (previewControls) previewControls.update();
      if (previewRenderer && previewScene && previewCamera) {
        previewRenderer.render(previewScene, previewCamera);
      }
    }

    function teardownPreview() {
      if (!previewRenderer) return;
      // Remove previous model
      if (previewRoot) {
        while (previewRoot.children.length) previewRoot.remove(previewRoot.children[0]);
      }
      previewSection.style.display = 'none';
      previewMsg.textContent = '';
    }

    function clearPreviewModel() {
      if (previewRoot) {
        while (previewRoot.children.length) previewRoot.remove(previewRoot.children[0]);
      }
      previewMsg.textContent = '';
    }

    function frameObject(obj) {
      // Compute bounding box to frame the object
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      // Re-center
      obj.position.sub(center);
      previewControls.target.set(0, 0, 0);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = previewCamera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
      cameraZ = cameraZ * 0.6; // little closer
      previewCamera.position.set(cameraZ, cameraZ * 0.2, cameraZ);
      previewCamera.near = cameraZ / 100;
      previewCamera.far = cameraZ * 100;
      previewCamera.updateProjectionMatrix();
    }

    function setupPreviewForFile(file) {
      const name = file.name.toLowerCase();
      if (!(name.endsWith('.stl') || name.endsWith('.3mf'))) {
        previewMsg.textContent = 'Endast .stl eller .3mf kan förhandsvisas.';
        previewSection.style.display = 'block';
        return;
      }

      // Make visible first so clientWidth/Height are correct
      previewSection.style.display = 'block';
      ensurePreviewInit();
      clearPreviewModel();
      onPreviewResize();
      previewMsg.textContent = 'Laddar förhandsvisning...';

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const arrayBuffer = reader.result;
          if (name.endsWith('.stl')) {
            const loader = new THREE.STLLoader();
            const geom = loader.parse(arrayBuffer);
            const mat = new THREE.MeshStandardMaterial({ color: 0x93c5fd, metalness: 0.1, roughness: 0.8 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = mesh.receiveShadow = true;
            previewRoot.add(mesh);
            frameObject(previewRoot);
            previewMsg.textContent = '';
          } else if (name.endsWith('.3mf')) {
            const loader = new THREE.ThreeMFLoader();
            const group = loader.parse(arrayBuffer);
            previewRoot.add(group);
            frameObject(previewRoot);
            previewMsg.textContent = '';
          }
        } catch (e) {
          console.error(e);
          previewMsg.textContent = 'Kunde inte läsa modellen.';
        }
      };
      reader.onerror = () => {
        previewMsg.textContent = 'Kunde inte läsa filen.';
      };
      reader.readAsArrayBuffer(file);
    }

  </script>
</body>
</html>
